<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.13">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Dev Notebook RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Dev Notebook Atom Feed">
<script src="https://www.googletagmanager.com/gtag/js?id=G-H8PHRNFHKD" async></script>
<script src="/ga.js"></script><title data-react-helmet="true">Caching Strategies (with a focus on microservices) | My Dev Notebook</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://www.mydevnotebook.com/Architecture/caching"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Caching Strategies (with a focus on microservices) | My Dev Notebook"><meta data-react-helmet="true" name="description" content="caching strategies, topologies, eviction strategies etc from a microservice perspective"><meta data-react-helmet="true" property="og:description" content="caching strategies, topologies, eviction strategies etc from a microservice perspective"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://www.mydevnotebook.com/Architecture/caching"><link data-react-helmet="true" rel="alternate" href="https://www.mydevnotebook.com/Architecture/caching" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://www.mydevnotebook.com/Architecture/caching" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.c20d7478.css">
<link rel="preload" href="/assets/js/runtime~main.470e3fc0.js" as="script">
<link rel="preload" href="/assets/js/main.d77e7fa0.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/notebook.png" alt="My Dev Notebook Logo" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/img/notebook.png" alt="My Dev Notebook Logo" class="themedImage_TMUO themedImage--dark_uzRr"></div><b class="navbar__title">My Dev Notebook</b></a><a class="navbar__item navbar__link navbar__link--active" href="/">Tech Articles</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">ðŸŒœ</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">ðŸŒž</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/">Welcome</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/Agile/scrum-cheatsheet">Agile</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_TwRn" href="/Architecture/Overview">Architecture</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/Architecture/Overview">Architecture Notes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Architecture/caching">Caching Strategies (with a focus on microservices)</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/Artificial Intelligence/ai">Artificial Intelligence</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/Design Patterns and Principles/adapter">Design Patterns and Principles</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/blog">Recent Blog Posts</a></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Caching Strategies (with a focus on microservices)</h1></header><h2 class="anchor anchorWithStickyNavbar_y2LR" id="topologies">Topologies<a aria-hidden="true" class="hash-link" href="#topologies" title="Direct link to heading">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="distributed">Distributed<a aria-hidden="true" class="hash-link" href="#distributed" title="Direct link to heading">â€‹</a></h3><p>A distributed cache is a client-server style cache. It is the cached data that is distributed, i.e. it&#x27;s distributed between
all the services that use it but there&#x27;s only a single cache server/service.</p><p><img alt="distributed cache diagram" src="/assets/images/distributed_cache-5a2b7a3d6e54686e6c7c0167257ca60d.png"></p><ul><li>Uses a separate server (e.g. redis or ignite etc)</li><li>All services using it use a client library to use the cache.</li><li>Each service does not have cached data; It has to access it from the server</li><li>Not fault tolerant, unless using a cluster</li></ul><p>The cache can store the data as</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>IMDG</td><td>In Memory Data Grid - Simple</td></tr><tr><td>IMDB</td><td>In Memory DataBase - Can have a schema and thus be more complex, allows use of SQL like queries against the cached data</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_y2LR" id="replicated">Replicated<a aria-hidden="true" class="hash-link" href="#replicated" title="Direct link to heading">â€‹</a></h3><p>This type of caching topology requires no external server. The cached data resides in each service, in memory. The cache
engine takes care of replicating the cached data amongst all instances, so it has &quot;eventual consistency&quot;. Fewer products
offer this type of caching compared to <a href="#Distributed">Distributed</a>, including <a href="https://ignite.apache.org/" target="_blank" rel="noopener noreferrer">Ignite</a>,
<a href="https://hazelcast.com/use-cases/caching/" target="_blank" rel="noopener noreferrer">Hazelcast</a>, <a href="https://tanzu.vmware.com/gemfire" target="_blank" rel="noopener noreferrer">GemFire</a>,
<a href="https://www.oracle.com/middleware/technologies/coherence.html" target="_blank" rel="noopener noreferrer">Coherence</a> and
others.</p><p><img alt="replicated cache diagram" src="/assets/images/replicated_cache-f986aa7b4d7dc11d4ad5c45ba5b5c8b5.png"></p><p>Eventual consistency is a by-product of how the cache operates. E.g. after a &quot;put&quot; onto the cache, the cache engine updates
the other instances in the background. Some systems allow concepts like <code>syncput()</code> to force consistency, but this shouldn&#x27;t
usually be necessary. The data replication engine (e.g. ignite) maintains a socket level connection to the other instances.</p><blockquote><p>Beware of your cache size! </p><p>For example on a shared host running a kubernetes cluster, 30 instances each with a 200 MB cache requires 6 GB of data!.</p></blockquote><p>Similar to above, this topology is not viable if you have large and/or lots of storage and/or instances.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="near-cache">Near Cache<a aria-hidden="true" class="hash-link" href="#near-cache" title="Direct link to heading">â€‹</a></h3><p>The near cache hybrid is a combination of a distributed and replicated cache. Each service has its own in memory cache,
known as the <strong>front cache</strong> (or MRU, or MFU cache depending on the eviction strategy used - see later). There is also a
distributed cache holding the full data set, known as the <strong>full backing cache</strong>. </p><p><img alt="near cache diagram" src="/assets/images/near_cache-b74a392a60c595ba2216d1bef2191a6d.png"></p><ul><li>There are no communications between services for cache management like in a replicated cache, instead this is managed by
the backing cache.</li><li>It allows a large amount of cached data in the full (backing) cache</li><li>A smaller subset of data is stored in each service&#x27;s front cache which might use MRU or MFU.</li><li>Individual front cache&#x27;s can therefore contain different datasets to each other  </li><li>It can suffer from inconsistent response times in some environments, especially in a microservice environment. This is
because the data might not exist in the local front cache, so we have to go to the backing cache, and maybe even all the
way to the database.
</li></ul><h2 class="anchor anchorWithStickyNavbar_y2LR" id="comparing-topologies">Comparing Topologies<a aria-hidden="true" class="hash-link" href="#comparing-topologies" title="Direct link to heading">â€‹</a></h2><table><thead><tr><th></th><th>Replicated</th><th>Distributed</th><th>Near Cache</th></tr></thead><tbody><tr><td>optimisation</td><td>performance</td><td>consistency</td><td>balanced</td></tr><tr><td>cache Size</td><td>small (&lt;100 MB)</td><td>large (500 MB +)</td><td>large (500 MB +)</td></tr><tr><td>type of data</td><td>relatively static</td><td>transactional</td><td>relatively static</td></tr><tr><td>update frequency</td><td>relatively low</td><td>high</td><td>relatively low</td></tr><tr><td>fault tolerance</td><td>high</td><td>low</td><td>low</td></tr><tr><td>responsiveness</td><td>high</td><td>medium</td><td>variable</td></tr></tbody></table><h2 class="anchor anchorWithStickyNavbar_y2LR" id="spaced-based-microservices">Spaced-based microservices<a aria-hidden="true" class="hash-link" href="#spaced-based-microservices" title="Direct link to heading">â€‹</a></h2><p>A challenge of microservices, particularly in migrating to them from a monolith, is how each service has its own data and
does not require access to a large central shared database. If there were many services sharing the same database, attempting
to make a schema change to that database would require very careful choreography to prevent breaking any services (or more
likely, you simply wouldn&#x27;t be able to make the change without breaking something).</p><p>With caching you can share a single database in a microservice environment. You can even version database changes, increase
performance, use cloud based data sync but on-prem database, and still have simple reporting and data analytics.</p><p><img alt="spaced based cache diagram" src="/assets/images/space_based-8aa326f1f7da72a2f206508d981365b3.png"></p><p>All data is stored in memory using replicated caches. Each service&#x27;s cache is a sub-set of the data in the database, but
a full data set for that particular services needs. Even if you have large database that is not practical to cache (e.g.
2 TB), the data required for an individual microservice might only be 200 MB of that 2 TB.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="reading-from-the-database">Reading from the database<a aria-hidden="true" class="hash-link" href="#reading-from-the-database" title="Direct link to heading">â€‹</a></h3><p>Reads from the database can happen in the following circumstances</p><ul><li>An external application updates the database. An async data writer will (eventually) update the cache data in this case</li><li>Cold starts - i.e. no instance of the service is already running from which to clone the data. This could be because
we lost all instances, or needed to perform a schema change or redeploy etc</li><li>Archiving of data (so cache needs renewing/refreshing)</li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="data-collisions">Data Collisions<a aria-hidden="true" class="hash-link" href="#data-collisions" title="Direct link to heading">â€‹</a></h3><p>When two service instances are operating at the same time, data collisions can occur. For example in an inventory
system, both instance caches might have the same stock level for an item, and both perform separate operations to decrement
the stock by different amounts (e.g. for different orders) <em>at the same time</em>. This means the service that completes last,
overwrites the change made by the first services operation. </p><p>This can be mitigated by not updating local caches but by performing a put operation to a queue. An <code>inventory adjust</code> service
could then be created to read from this queue, apply each update in turn to itself and its own cache which would then replicate
to the other services as normal. The trade-off is the time to eventual consistency.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="cache-eviction-policies">Cache eviction policies<a aria-hidden="true" class="hash-link" href="#cache-eviction-policies" title="Direct link to heading">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="ttl">TTL<a aria-hidden="true" class="hash-link" href="#ttl" title="Direct link to heading">â€‹</a></h3><p>Time to live, is a simple timeout parameter. It doesn&#x27;t address a full cache scenario</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="arc">ARC<a aria-hidden="true" class="hash-link" href="#arc" title="Direct link to heading">â€‹</a></h3><p>Archive policy (ARC) evicts item based on date created (NOT when it was added to the cache). For example evict all items
older than 6 months. It doesn&#x27;t address a full cache scenario</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="lfu">LFU<a aria-hidden="true" class="hash-link" href="#lfu" title="Direct link to heading">â€‹</a></h3><p>Least frequently used. Items have an internal &quot;count&quot; of how often it is read. A put operation must reset this internal
count for all items (otherwise the item just added would most likely be evicted again), so this can be suboptimal.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="lru">LRU<a aria-hidden="true" class="hash-link" href="#lru" title="Direct link to heading">â€‹</a></h3><p>Least recently used. All items get an &quot;age&quot;. Oldest item gets evicted on put. On cache item hit, that individual items age
is set to zero and all other items ages are incremented. This is more effective than LFU, but more expensive because of
the re-aging process.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="rr">RR<a aria-hidden="true" class="hash-link" href="#rr" title="Direct link to heading">â€‹</a></h3><p>Random replacement. If doing a put on a full cache, then randomly evict an item. This can be a good initial strategy if
you don&#x27;t know much about you data / hotspots, or for when data access is inconsistent or non-deterministic.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/Architecture/Overview"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« <!-- -->Architecture Notes</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/Artificial Intelligence/ai"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Artificial Intelligence (AI)<!-- --> Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#topologies" class="table-of-contents__link toc-highlight">Topologies</a><ul><li><a href="#distributed" class="table-of-contents__link toc-highlight">Distributed</a></li><li><a href="#replicated" class="table-of-contents__link toc-highlight">Replicated</a></li><li><a href="#near-cache" class="table-of-contents__link toc-highlight">Near Cache</a></li></ul></li><li><a href="#comparing-topologies" class="table-of-contents__link toc-highlight">Comparing Topologies</a></li><li><a href="#spaced-based-microservices" class="table-of-contents__link toc-highlight">Spaced-based microservices</a><ul><li><a href="#reading-from-the-database" class="table-of-contents__link toc-highlight">Reading from the database</a></li><li><a href="#data-collisions" class="table-of-contents__link toc-highlight">Data Collisions</a></li></ul></li><li><a href="#cache-eviction-policies" class="table-of-contents__link toc-highlight">Cache eviction policies</a><ul><li><a href="#ttl" class="table-of-contents__link toc-highlight">TTL</a></li><li><a href="#arc" class="table-of-contents__link toc-highlight">ARC</a></li><li><a href="#lfu" class="table-of-contents__link toc-highlight">LFU</a></li><li><a href="#lru" class="table-of-contents__link toc-highlight">LRU</a></li><li><a href="#rr" class="table-of-contents__link toc-highlight">RR</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 MyDevNotebook.com. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.470e3fc0.js"></script>
<script src="/assets/js/main.d77e7fa0.js"></script>
</body>
</html>