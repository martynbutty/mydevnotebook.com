"use strict";(self.webpackChunkmydevnotebook_com=self.webpackChunkmydevnotebook_com||[]).push([[9095],{3541:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>h});var t=s(4848),i=s(8453);const o={title:"Composition vs Inheritance"},a=void 0,r={id:"Design Patterns and Principles/composition",title:"Composition vs Inheritance",description:"Composition and inheritance class diagram",source:"@site/docs/Design Patterns and Principles/composition.md",sourceDirName:"Design Patterns and Principles",slug:"/Design Patterns and Principles/composition",permalink:"/Design Patterns and Principles/composition",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Composition vs Inheritance"},sidebar:"tutorialSidebar",previous:{title:"The Bridge Pattern",permalink:"/Design Patterns and Principles/bridge"},next:{title:"Compound Patterns",permalink:"/Design Patterns and Principles/compound"}},c={},h=[{value:"Choosing between composition and inheritance",id:"choosing-between-composition-and-inheritance",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.RP)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Composition and inheritance class diagram",src:s(6641).A+"",width:"500",height:"335"})}),"\n",(0,t.jsxs)(n.p,{children:["So how exactly do ",(0,t.jsx)(n.strong,{children:"composition"})," and ",(0,t.jsx)(n.strong,{children:"inheritance"})," compare? Here are several points of comparison:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["It is easier to ",(0,t.jsx)(n.strong,{children:"change the interface of a back-end class"})," (composition) than a superclass (inheritance). A change\nto the interface of a back-end class necessitates a change to the front-end class ",(0,t.jsx)(n.em,{children:"implementation"}),", but not necessarily\nthe front-end interface. Code that depends only on the front-end interface still works, so long as the front-end interface\nremains the same. By contrast, a change to a superclass's interface can not only ripple down the inheritance hierarchy\nto subclasses, but can also ripple out to code that uses just the subclass's interface see the ",(0,t.jsx)(n.a,{href:"fragile",children:"fragile base class"}),"\nfor an example."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["It is easier to **change the interface of a front-end class ** (composition) than a subclass (inheritance). Just as\nsuperclasses can be fragile, ",(0,t.jsx)(n.strong,{children:"subclasses can be rigid"}),". You can't just change a subclass's interface without\nmaking sure the subclass's new interface is compatible with that of its parent (supertypes). For example, you can't\nadd to a subclass a method with the same signature but a different return type as a method inherited from a superclass.\nComposition, on the other hand, allows you to change the interface of a front-end class without affecting back-end classes."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Composition_allows you to ",(0,t.jsx)(n.strong,{children:"delay the creation of back-end objects"})," until (and unless) they are needed, as well as\nchanging the back-end objects dynamically throughout the lifetime of the front-end object. With ",(0,t.jsx)(n.em,{children:"inheritance"}),", you get\nthe image of the superclass in your subclass object image as soon as the subclass is created, and it remains part of\nthe subclass object throughout the lifetime of the subclass."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["It is ",(0,t.jsx)(n.strong,{children:"easier to add new subclasses"})," (inheritance) than it is to add new front-end classes (composition), because\n",(0,t.jsx)(n.strong,{children:"inheritance comes with polymorphism"}),". If you have a bit of code that relies only on a superclass interface, that\ncode can work with a new subclass without change. This is not true of composition, unless you use composition with interfaces.\nUsed together, ",(0,t.jsx)(n.strong,{children:"composition and abstract (or interface) classes"})," make a very powerful design tool."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The explicit ",(0,t.jsx)(n.strong,{children:"method-invocation forwarding"})," (or delegation) approach of composition will often have a ",(0,t.jsx)(n.strong,{children:"performance\ncost"})," as compared to inheritance's single invocation of an inherited superclass method implementation."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["With both composition and inheritance, ",(0,t.jsx)(n.strong,{children:"changing the implementation"})," (not the interface) of any class is easy.\nThe ripple effect of implementation changes remain inside the same class."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"choosing-between-composition-and-inheritance",children:"Choosing between composition and inheritance"}),"\n",(0,t.jsx)(n.p,{children:"So how do all these comparisons between composition and inheritance help you in your designs? Here are a few guidelines\nthat reflect how I tend to select between composition and inheritance."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Make sure inheritance models the ",(0,t.jsx)(n.em,{children:"is-a"})," relationship."]})," The main guiding philosophy is that inheritance should be used\nonly when a subclass ",(0,t.jsx)(n.em,{children:"is-a"})," superclass. For example, an ",(0,t.jsx)(n.code,{children:"Apple"})," likely ",(0,t.jsx)(n.em,{children:"is-a"})," ",(0,t.jsx)(n.code,{children:"Fruit"}),", so I would be inclined to use inheritance.\nAn important question to ask yourself when you think you have an ",(0,t.jsx)(n.em,{children:"is-a"})," relationship is whether that ",(0,t.jsx)(n.em,{children:"is-a"})," relationship\nwill be constant throughout the lifetime of the application and, with luck, the lifecycle of the code. For example, you might\nthink that an ",(0,t.jsx)(n.code,{children:"Employee"})," ",(0,t.jsx)(n.em,{children:"is-a"})," ",(0,t.jsx)(n.code,{children:"Person"}),", when really ",(0,t.jsx)(n.code,{children:"Employee"})," represents a role that a ",(0,t.jsx)(n.code,{children:"Person"})," plays part of the time.\nWhat if the person becomes unemployed? What if the person is both an ",(0,t.jsx)(n.code,{children:"Employee"})," and a ",(0,t.jsx)(n.code,{children:"Supervisor"}),"? Such impermanent ",(0,t.jsx)(n.em,{children:"is-a"}),"\nrelationships should usually be modeled with composition."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Don't use inheritance just to get code reuse"})," If all you really want is to reuse code and there is no ",(0,t.jsx)(n.em,{children:"is-a"})," relationship\nin sight, use composition."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Don't use inheritance just to get at polymorphism"})," If all you really want is polymorphism, but there is no natural\n",(0,t.jsx)(n.em,{children:"is-a"})," relationship, use composition with abstract classes."]})]})}function d(e={}){const{wrapper:n}={...(0,i.RP)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},6641:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/composition_vs_inheritance-fc075ca37f3b97395936570c79e20d0e.png"},8453:(e,n,s)=>{s.d(n,{RP:()=>o});var t=s(6540);const i=t.createContext({});function o(e){const n=t.useContext(i);return t.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);