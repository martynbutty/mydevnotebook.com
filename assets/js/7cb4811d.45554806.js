"use strict";(self.webpackChunkmydevnotebook_com=self.webpackChunkmydevnotebook_com||[]).push([[6265],{9638:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var t=n(4848),s=n(8453);const a={title:"Design Principles"},o=void 0,r={id:"Design Patterns and Principles/design-principles",title:"Design Principles",description:"These are some of the more important design principles and strategies to consider during your OOP software design and development activities.",source:"@site/docs/Design Patterns and Principles/design-principles.md",sourceDirName:"Design Patterns and Principles",slug:"/Design Patterns and Principles/design-principles",permalink:"/Design Patterns and Principles/design-principles",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Design Principles"},sidebar:"tutorialSidebar",previous:{title:"Decorator Pattern",permalink:"/Design Patterns and Principles/decorator"},next:{title:"The Facade Pattern",permalink:"/Design Patterns and Principles/facade"}},c={},l=[{value:"Objects are things with well defined responsibilities",id:"objects-are-things-with-well-defined-responsibilities",level:2},{value:"Objects are responsible for themselves",id:"objects-are-responsible-for-themselves",level:2},{value:"Encapsulation means any kind of hiding",id:"encapsulation-means-any-kind-of-hiding",level:2},{value:"Encapsulate what varies",id:"encapsulate-what-varies",level:2},{value:"Abstraction is the representation of an entity in non-concrete terms",id:"abstraction-is-the-representation-of-an-entity-in-non-concrete-terms",level:2},{value:"Abstract out variations in behaviour and data with commonality and variability analysis (CVA)",id:"abstract-out-variations-in-behaviour-and-data-with-commonality-and-variability-analysis-cva",level:2},{value:"Program to an interface not an implementation",id:"program-to-an-interface-not-an-implementation",level:2},{value:"Favour composition (or aggregation) over inheritance",id:"favour-composition-or-aggregation-over-inheritance",level:2},{value:"Think of inheritance as a way of conceptualising variation",id:"think-of-inheritance-as-a-way-of-conceptualising-variation",level:2},{value:"Keep variations in a class decoupled from other variations in the class",id:"keep-variations-in-a-class-decoupled-from-other-variations-in-the-class",level:2},{value:"Strive for loose coupling",id:"strive-for-loose-coupling",level:2},{value:"Strive for strong cohesion",id:"strive-for-strong-cohesion",level:2},{value:"Separate the code that uses an object from code that creates the object",id:"separate-the-code-that-uses-an-object-from-code-that-creates-the-object",level:2},{value:"Apply the once and only once rule",id:"apply-the-once-and-only-once-rule",level:2},{value:"Open Closed Principle (OCP)",id:"open-closed-principle-ocp",level:2},{value:"Dependency Inversion Principle (DIP)",id:"dependency-inversion-principle-dip",level:2},{value:"The Liskov Substitution Principle (LSP)",id:"the-liskov-substitution-principle-lsp",level:2},{value:"Ensure that your code is readable",id:"ensure-that-your-code-is-readable",level:2},{value:"Consider the testability of your code before coding it",id:"consider-the-testability-of-your-code-before-coding-it",level:2},{value:"Further Reading",id:"further-reading",level:2}];function h(e){const i={a:"a",em:"em",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.RP)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:"These are some of the more important design principles and strategies to consider during your OOP software design and development activities."}),"\n",(0,t.jsx)(i.h2,{id:"objects-are-things-with-well-defined-responsibilities",children:"Objects are things with well defined responsibilities"}),"\n",(0,t.jsx)(i.p,{children:"At a conceptual level an object is a set of responsibilities (at a specification level it is a set of methods, at an implementation level an object is code and data). The responsibilities define the behaviour of the object. This focuses on what objects are supposed to do and its public interface, rather than the actual implementation."}),"\n",(0,t.jsx)(i.h2,{id:"objects-are-responsible-for-themselves",children:"Objects are responsible for themselves"}),"\n",(0,t.jsx)(i.p,{children:"The more that objects become responsible for their own behaviours, the less the controlling programs have to be responsible for them. Careful thought must be given to the separation of responsibilities between objects."}),"\n",(0,t.jsx)(i.h2,{id:"encapsulation-means-any-kind-of-hiding",children:"Encapsulation means any kind of hiding"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Data hiding (private data or object composition)"}),"\n",(0,t.jsx)(i.li,{children:"Implementation hiding (private methods or Strategy/Bridge pattern)"}),"\n",(0,t.jsx)(i.li,{children:"Class hiding (behind an abstract class)"}),"\n",(0,t.jsx)(i.li,{children:"Design hiding (Fa\xe7ade pattern)"}),"\n",(0,t.jsx)(i.li,{children:"Instantiation hiding (with factories)"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"encapsulate-what-varies",children:"Encapsulate what varies"}),"\n",(0,t.jsx)(i.p,{children:"Encapsulated behaviour means that changes to an object\u2019s internal behaviour becomes transparent to other objects. Encapsulation therefore helps to prevent unwanted side-effects because when something is encapsulated, it becomes loosely coupled to the user. The encapsulating layers become the interfaces to design to. Many design patterns utilise this principle and it is an important way of thinking about software design."}),"\n",(0,t.jsx)(i.h2,{id:"abstraction-is-the-representation-of-an-entity-in-non-concrete-terms",children:"Abstraction is the representation of an entity in non-concrete terms"}),"\n",(0,t.jsx)(i.p,{children:"The process of abstraction within computer science allows you to deal with ideas and entities without being encumbered by unnecessary details. Abstraction is generally accomplished either through abstract classes and interfaces, or with conceptual layers of functionality which expose only the necessary elements of a lower level set of components. The goal of abstraction is generally to allow one or both sides of a relationship to vary independently from the other. For example, if a presentation layer accesses a database through a domain layer serving as the layer of abstraction, the database and method of access can be modified without affecting the presentation layer."}),"\n",(0,t.jsx)(i.h2,{id:"abstract-out-variations-in-behaviour-and-data-with-commonality-and-variability-analysis-cva",children:"Abstract out variations in behaviour and data with commonality and variability analysis (CVA)"}),"\n",(0,t.jsx)(i.p,{children:"Commonality analysis seeks structure that is unlikely to change over time, while variability analysis captures structure that is likely to change within the common set. The commonality analysis is a conceptual perspective where the common concepts will be represented by abstract classes; the variations within the common concept will be implemented by concrete classes. The interface for the abstract class must cater for all the variations among the concrete sub-classes. In general using CVA helps us discover patterns in the problem domain."}),"\n",(0,t.jsx)(i.h2,{id:"program-to-an-interface-not-an-implementation",children:"Program to an interface not an implementation"}),"\n",(0,t.jsx)(i.p,{children:"Because the interface (or abstract class) represents an abstraction that is unlikely to change; it also hides the subclasses from the client, and helps maintain the \u201conce and only once\u201d principle."}),"\n",(0,t.jsx)(i.h2,{id:"favour-composition-or-aggregation-over-inheritance",children:"Favour composition (or aggregation) over inheritance"}),"\n",(0,t.jsxs)(i.p,{children:["When a class composes (or aggregates) an object instead of extending an inheritance hierarchy, it improves the cohesion of the class and decouples the implementation of the aggregated object. Inheritance hierarchies also suffer from the ",(0,t.jsx)(i.a,{href:"fragile",children:"fragile base class problem"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"think-of-inheritance-as-a-way-of-conceptualising-variation",children:"Think of inheritance as a way of conceptualising variation"}),"\n",(0,t.jsxs)(i.p,{children:["not for making special cases of existing objects. Instead of considering what might force a change to a design, ",(0,t.jsx)(i.em,{children:"consider what you want to be able to change without redesign"}),", and then to ",(0,t.jsx)(i.strong,{children:"encapsulate what varies"}),". Using inheritance for special cases can lead to:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Tight coupling because features are indirectly related to each other in the inheritance hierarchy"}),"\n",(0,t.jsx)(i.li,{children:"Weak cohesion because methods that performed core functions are scattered among classes"}),"\n",(0,t.jsx)(i.li,{children:"High redundancy with similarity of code in different classes"}),"\n",(0,t.jsx)(i.li,{children:"Potential class explosion when a new type of specialisation or super class is introduced"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"keep-variations-in-a-class-decoupled-from-other-variations-in-the-class",children:"Keep variations in a class decoupled from other variations in the class"}),"\n",(0,t.jsxs)(i.p,{children:["In the ",(0,t.jsx)(i.a,{href:"bridge",children:"Bridge pattern"})," there are two variations in the problem domain. There is a variation of the basic type, this leads to an abstract class and various concrete subclasses. Then there is a variation in method implementations, this results in a separate abstract class with a variety of concrete implementations. The first inheritance hierarchy aggregates the second, and hence the two are decoupled."]}),"\n",(0,t.jsx)(i.h2,{id:"strive-for-loose-coupling",children:"Strive for loose coupling"}),"\n",(0,t.jsx)(i.p,{children:"Loose coupling is the state of possessing an association or awareness from one component or system to another by means of abstraction (interface or abstract class). Loose coupling provides the ability for one component to be associated with another while allowing independent variation. For example, if component A interacts with component B through an abstraction of component B, the implementation of component B can be changed without affecting component A. This contrasts with tight coupling \u2013 the state of possessing a direct association or awareness between one component or system and another which affects the ability for the associating component or system to vary independently. Decoupling is the process of disconnecting an association or awareness of two components or systems."}),"\n",(0,t.jsx)(i.h2,{id:"strive-for-strong-cohesion",children:"Strive for strong cohesion"}),"\n",(0,t.jsx)(i.p,{children:'Cohesion is a measure of how strongly related and focused the various responsibilities of a software module are. Cohesion is usually expressed as "high (strong) cohesion" or "low (weak) cohesion" when being discussed. Modules with high cohesion tend to be preferable because high cohesion is associated with several desirable traits of software including:'}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Robustness"}),"\n",(0,t.jsx)(i.li,{children:"Reliability"}),"\n",(0,t.jsx)(i.li,{children:"Reusability"}),"\n",(0,t.jsx)(i.li,{children:"Understandability"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Whereas low cohesion is associated with undesirable traits such as being difficult to maintain, difficult to test, difficult to reuse, and even difficult to understand."}),"\n",(0,t.jsx)(i.h2,{id:"separate-the-code-that-uses-an-object-from-code-that-creates-the-object",children:"Separate the code that uses an object from code that creates the object"}),"\n",(0,t.jsx)(i.p,{children:"This is done by the use of factories, so that the code that uses an object does not need to know how to create that object."}),"\n",(0,t.jsx)(i.h2,{id:"apply-the-once-and-only-once-rule",children:"Apply the once and only once rule"}),"\n",(0,t.jsx)(i.p,{children:"If there is a rule on how to do things, then only implement that rule once. Therefore write a method for the rule that can be called where required. Duplication is bad because if it needs to be changed it will have to be changed in several places, not just one. Hence different parts of the code would be coupled to each other where the duplication exists. Also known as \u2018Don\u2019t Repeat Yourself\u2019 (DRY)."}),"\n",(0,t.jsx)(i.h2,{id:"open-closed-principle-ocp",children:"Open Closed Principle (OCP)"}),"\n",(0,t.jsx)(i.p,{children:"Software should be designed so that you can extend its capabilities without changing it. I.e. when a new requirement arises, this should be able to be implemented by extending (e.g. adding new classes) the software rather than modifying existing methods or classes."}),"\n",(0,t.jsx)(i.h2,{id:"dependency-inversion-principle-dip",children:"Dependency Inversion Principle (DIP)"}),"\n",(0,t.jsx)(i.p,{children:"The dependency inversion principle states that high level modules should not depend on low level modules, instead both should depend on abstractions."}),"\n",(0,t.jsx)(i.h2,{id:"the-liskov-substitution-principle-lsp",children:"The Liskov Substitution Principle (LSP)"}),"\n",(0,t.jsx)(i.p,{children:"A class deriving from a base class should support all the behaviour of the base class, hence both base class and derived classes can be used interchangeably. An object that uses a reference passed to it should not care if that reference is to the base class or the derived class. This implies that subtypes should not add new public methods."}),"\n",(0,t.jsx)(i.p,{children:"LSP helps us to have well designed inheritance. If your subclass cannot be substituted for the base class which it inherits from, without causing problems (for example methods with the same name but different signatures) the your design does not satisfy LSP. In this case, consider alternative approaches such as using delegation or composition (i.e. the old subclass will hold an instance of the base class)."}),"\n",(0,t.jsx)(i.h2,{id:"ensure-that-your-code-is-readable",children:"Ensure that your code is readable"}),"\n",(0,t.jsx)(i.p,{children:"By \u201cprogramming by intention\u201d and by using intention-revealing names. Give methods and attributes \u201cintention-revealing names\u201d hence calls to methods are named in a way that clearly describes their intended use."}),"\n",(0,t.jsx)(i.h2,{id:"consider-the-testability-of-your-code-before-coding-it",children:"Consider the testability of your code before coding it"}),"\n",(0,t.jsx)(i.p,{children:"Testable code is code that can be tested in isolation without having to worry about how it is coupled to other modules or entities. Testable code is:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"More cohesive because the code is only about one thing"}),"\n",(0,t.jsx)(i.li,{children:"More loosely coupled because there are minimal interactions to worry about"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(i.p,{children:["For a good list of design principles see:",(0,t.jsx)(i.a,{href:"http://mmiika.wordpress.com/oo-design-principles/",children:"http://mmiika.wordpress.com/oo-design-principles/"})]}),"\n",(0,t.jsx)(i.p,{children:"Note the five foundational principles that provide the acronym SOLID."})]})}function d(e={}){const{wrapper:i}={...(0,s.RP)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,i,n)=>{n.d(i,{RP:()=>a});var t=n(6540);const s=t.createContext({});function a(e){const i=t.useContext(s);return t.useMemo((()=>"function"==typeof e?e(i):{...i,...e}),[i,e])}}}]);