"use strict";(self.webpackChunkmydevnotebook_com=self.webpackChunkmydevnotebook_com||[]).push([[8034],{6897:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var s=a(4848),n=a(8453);const r={title:"The Strategy Pattern"},i=void 0,o={id:"Design Patterns and Principles/strategy",title:"The Strategy Pattern",description:"strategy pattern class diagram",source:"@site/docs/Design Patterns and Principles/strategy.md",sourceDirName:"Design Patterns and Principles",slug:"/Design Patterns and Principles/strategy",permalink:"/Design Patterns and Principles/strategy",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"The Strategy Pattern"},sidebar:"tutorialSidebar",previous:{title:"The Fragile Base Class Problem",permalink:"/Design Patterns and Principles/fragile"}},c={},l=[];function h(e){const t={em:"em",img:"img",p:"p",...(0,n.RP)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"strategy pattern class diagram",src:a(5473).A+"",width:"1024",height:"407"})}),"\n",(0,s.jsx)(t.p,{children:"The GoF describe the strategy pattern as;"}),"\n",(0,s.jsx)(t.p,{children:"Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it."}),"\n",(0,s.jsx)(t.p,{children:"The strategy pattern enables you to use different rules or algorithms depending on the context they occur. For example in a system calculating the tax due on different assetts, different tax rules (algorithms) are used depending on the type of asset being considered."}),"\n",(0,s.jsxs)(t.p,{children:["The strategy pattern defines a family of algorithms. It helps to eliminate complex switches and conditionals (if...elseif...else). The algorithms are invoked the same way (as they must all have the same ",(0,s.jsx)(t.em,{children:"interface"}),")."]}),"\n",(0,s.jsx)(t.p,{children:"The class that uses the algorithm (Context) contains an abstract class (Strategy) that has an abstract method which specifies how to call the algorithm. Each derived class (ConcreteStrategy) implements the algorithm as needed. Typically, the responsibility for selecting which concrete implementation to use is done by the client object, and is given to the context object of the strategy pattern."})]})}function d(e={}){const{wrapper:t}={...(0,n.RP)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},5473:(e,t,a)=>{a.d(t,{A:()=>s});const s=a.p+"assets/images/strategy_pattern-4a7a35ea12a3f4ecfc8d51588e5ee8a6.png"},8453:(e,t,a)=>{a.d(t,{RP:()=>r});var s=a(6540);const n=s.createContext({});function r(e){const t=s.useContext(n);return s.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}}}]);