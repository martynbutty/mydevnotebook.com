"use strict";(self.webpackChunkmydevnotebook_com=self.webpackChunkmydevnotebook_com||[]).push([[287],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=a,m=d["".concat(l,".").concat(u)]||d[u]||h[u]||i;return n?r.createElement(m,o(o({ref:t},c),{},{components:n})):r.createElement(m,o({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:a,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6932:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return o},default:function(){return h},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return p}});var r=n(3117),a=(n(7294),n(3905));const i={title:"The Bridge Pattern"},o=void 0,s={unversionedId:"Design Patterns and Principles/bridge",id:"Design Patterns and Principles/bridge",title:"The Bridge Pattern",description:"The bridge pattern is similar to the strategy pattern, where you define a family of algorithms, encapsulate each one, and make them interchangeable.  Strategy lets the algorithm vary independently from clients that use it. The bridge pattern decouples an abstraction from its implementation so that the two can vary independently.",source:"@site/docs/Design Patterns and Principles/bridge.md",sourceDirName:"Design Patterns and Principles",slug:"/Design Patterns and Principles/bridge",permalink:"/Design Patterns and Principles/bridge",draft:!1,tags:[],version:"current",frontMatter:{title:"The Bridge Pattern"},sidebar:"tutorialSidebar",previous:{title:"The Adapter Pattern",permalink:"/Design Patterns and Principles/adapter"},next:{title:"Composition vs Inheritance",permalink:"/Design Patterns and Principles/composition"}},l={},p=[{value:"How the bridge pattern can help",id:"how-the-bridge-pattern-can-help",level:3},{value:"Class diagram for the bridge pattern",id:"class-diagram-for-the-bridge-pattern",level:3},{value:"Why not use the adapter pattern?",id:"why-not-use-the-adapter-pattern",level:3}],c={toc:p},d="wrapper";function h(e){let{components:t,...i}=e;return(0,a.kt)(d,(0,r.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The bridge pattern is similar to the ",(0,a.kt)("a",{parentName:"p",href:"strategy"},"strategy pattern"),", where you define a family of algorithms, encapsulate each one, and make them interchangeable.  Strategy lets the algorithm vary independently from clients that use it. The bridge pattern decouples an abstraction from its implementation so that the two can vary independently."),(0,a.kt)("p",null,"Consider the following example: A system comprises of shapes which must be drawn. There are different implementations of the shapes, and different drawing programs to draw the shape. Using inheritance specialisation to solve this problem results in a class explosion (especially as new shape or drawing program implementations are added). An inheritance based solution would produce the following class diagram."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Problem to be solved by bridge pattern",src:n(3802).Z,width:"800",height:"699"})),(0,a.kt)("p",null,'What would happen in the above solution if a new "V3" drawing implementation and another shape was added to the system? We have a class explosion as each shape must know its type of drawing program (DP), hence it is also tightly coupled to it.'),(0,a.kt)("h3",{id:"how-the-bridge-pattern-can-help"},"How the bridge pattern can help"),(0,a.kt)("p",null,"We need to separate (decouple) the variations in abstraction (shape) from the variations in implementation (draw) so that the two can vary independently. The two basic strategies to use to move towards a solution are"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Encapsulate what varies (behind an abstract class)"),(0,a.kt)("li",{parentName:"ul"},"Favour composition over inheritance")),(0,a.kt)("p",null,"The shape and drawing vary, therefore these become our abstract classes. Then we tie the two together using aggregation (composition). This produces the following class diagram (which implements the bridge pattern):"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"bridge pattern solution",src:n(3261).Z,width:"2187",height:"1104"})),(0,a.kt)("p",null,"To clarify the opening statements about the bridge pattern, ",(0,a.kt)("strong",{parentName:"p"},"the")," ",(0,a.kt)("strong",{parentName:"p"},"abstraction")," defines the interface for the objects being implemented (shapes). ",(0,a.kt)("strong",{parentName:"p"},"The implementor")," defines the interface for the specific implementation classes (drawing programs). Classes derived from ",(0,a.kt)("inlineCode",{parentName:"p"},"Abstraction")," use classes derived from ",(0,a.kt)("inlineCode",{parentName:"p"},"Implementor")," without knowing which particular concrete implementor is in use. This decouples the implementations from the objects that use them."),(0,a.kt)("h3",{id:"class-diagram-for-the-bridge-pattern"},"Class diagram for the bridge pattern"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"The bridge pattern",src:n(8422).Z,width:"1723",height:"667"})),(0,a.kt)("h3",{id:"why-not-use-the-adapter-pattern"},"Why not use the adapter pattern?"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"adapter"},"adapter pattern")," works well and the implementation isn\u2019t too different from the bridge pattern (but it is different). However we need to discuss when to use the adapter versus the bridge."),(0,a.kt)("p",null,"The adapter is great if you are adapting concrete functionality from one application to be used by another.  In other words, I need to adapt Application A so that it looks like it is part of Application B."),(0,a.kt)("p",null,"The Bridge pattern is better suited for designing a system where you expect to add additional functionality over time, but you want your architecture to be flexible enough to handle the changes without becoming brittle.  This brittleness often occurs as you attempt to add new functionality using traditional factoring and \u201cIs-A\u201d mentality."))}h.isMDXComponent=!0},8422:function(e,t,n){t.Z=n.p+"assets/images/bridge-pattern-c4638ea97d0886a5bd61dd50d7e71d81.png"},3802:function(e,t,n){t.Z=n.p+"assets/images/bridge-problem-be2e60b8e5744c7c17a89c223850921c.png"},3261:function(e,t,n){t.Z=n.p+"assets/images/bridge-solution-01db647a3bb89722fb50fd6f8abcf2e5.png"}}]);