"use strict";(self.webpackChunkmydevnotebook_com=self.webpackChunkmydevnotebook_com||[]).push([[5028],{634:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var r=i(4848),n=i(8453);const s={},a="Architecture Notes",o={id:"Architecture/Overview",title:"Architecture Notes",description:"Architecture is about balancing requirements to try and come up with something that's the least worst solution.",source:"@site/docs/Architecture/Overview.md",sourceDirName:"Architecture",slug:"/Architecture/Overview",permalink:"/Architecture/Overview",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Scrum Cheat Sheet",permalink:"/Agile/scrum-cheatsheet"},next:{title:"Caching Strategies (with a focus on microservices)",permalink:"/Architecture/caching"}},c={},l=[{value:"Anti-Patterns",id:"anti-patterns",level:2},{value:"Architecture Patterns",id:"architecture-patterns",level:2},{value:"Architectural Characteristics",id:"architectural-characteristics",level:2},{value:"Architecture Styles",id:"architecture-styles",level:2},{value:"Service Based Architecture",id:"service-based-architecture",level:3},{value:"Modular Monolith",id:"modular-monolith",level:3},{value:"Monoliths",id:"monoliths",level:3},{value:"Event-Driven",id:"event-driven",level:3},{value:"Space Based",id:"space-based",level:3},{value:"Microservices Challenge",id:"microservices-challenge",level:3},{value:"Hybrid Architecture",id:"hybrid-architecture",level:3},{value:"Distributed Architecture Consdierations",id:"distributed-architecture-consdierations",level:2},{value:"The Fallacies of Distributed Computing",id:"the-fallacies-of-distributed-computing",level:2},{value:"The Network is Reliable",id:"the-network-is-reliable",level:3},{value:"Latency is Zero",id:"latency-is-zero",level:3},{value:"Service Granularity",id:"service-granularity",level:2},{value:"Granularity Disintegrators",id:"granularity-disintegrators",level:3},{value:"Granularity Integrators",id:"granularity-integrators",level:3}];function h(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.RP)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"architecture-notes",children:"Architecture Notes"}),"\n",(0,r.jsxs)(t.p,{children:["Architecture is about balancing requirements to try and come up with something that's the ",(0,r.jsx)(t.strong,{children:"least worst"})," solution."]}),"\n",(0,r.jsxs)(t.p,{children:["In most systems, you can't satisfy one architectual characterisitic without that having an impact on other characterisitcs. Search for ",(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.em,{children:'"ship called the Vasa"'})})," for an example of what can go wrong if you try to do too much."]}),"\n",(0,r.jsx)(t.p,{children:"For example if you want your system to be highly secure, then you may have to sacrifice some performance becuase of the extra processing overhead of security concerns."}),"\n",(0,r.jsx)(t.h2,{id:"anti-patterns",children:"Anti-Patterns"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Cover your assets - Avoiding making any decision for fear of making the wrong one"}),"\n",(0,r.jsx)(t.li,{children:"Groundhog day - nobody understands why a decision was made so it keeps getting discussed over and over (hint - ADR's can help here)"}),"\n",(0,r.jsx)(t.li,{children:"Email driven architecture - People forget / lose / don't know / didn't read / weren't around when an email about an architecture\ndecision was sent, therefore don't implement it correctly (ADR's can help here too!)"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"architecture-patterns",children:"Architecture Patterns"}),"\n",(0,r.jsxs)(t.p,{children:['CQRS is a pattern, but not a style. The difference spans from questions like "is CQRS a pattern, and is microkernel\ndifferent from CQRS?" I.e. you can deploy a ',(0,r.jsx)(t.em,{children:"pattern"})," like CQRS into systems using the architectural ",(0,r.jsx)(t.em,{children:"styles"})," like microservices,\nspace based, event driven and modular monolith etc."]}),"\n",(0,r.jsx)(t.h2,{id:"architectural-characteristics",children:"Architectural Characteristics"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"A non-domain design consideration"}),"\n",(0,r.jsx)(t.li,{children:"Influences some structural aspect of the design"}),"\n",(0,r.jsx)(t.li,{children:"Critical or important to application success"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"architecture-styles",children:"Architecture Styles"}),"\n",(0,r.jsx)(t.h3,{id:"service-based-architecture",children:"Service Based Architecture"}),"\n",(0,r.jsx)(t.p,{children:"Is a hybrid of microservices. Well defined domains deployed as separate units. Shared data like modular monolith (unlike\nmicroservices where each service owns its own data)"}),"\n",(0,r.jsx)(t.h3,{id:"modular-monolith",children:"Modular Monolith"}),"\n",(0,r.jsx)(t.p,{children:"Becoming more popular. Single deployment unit with functionality grouped by domain. Popular with DDD."}),"\n",(0,r.jsx)(t.p,{children:"Can be a good start point to get something out the door to prove it, save money, evolve the architecture or if you're just\nnot sure if a distributed architecture will work."}),"\n",(0,r.jsxs)(t.p,{children:["Next step might be to move to ",(0,r.jsx)(t.strong,{children:"service based architecture:"})]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Take all the domain area's (e.g. by namespace in code like app.customer.*)"}),"\n",(0,r.jsx)(t.li,{children:"Pull them individually out of the modular monolith so they's an independently deployable unit of software (but shared DB maybe)"}),"\n",(0,r.jsxs)(t.li,{children:["Look at each of these domains to see which could/should be deployed as single purpose functions (i.e. ",(0,r.jsx)(t.strong,{children:"microservices"}),")"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"monoliths",children:"Monoliths"}),"\n",(0,r.jsx)(t.p,{children:'Service oriented architecture (SOA) and Layered are still viable in the right place. Especially if using integrated communications between heterogeneous enterprise systems (eg an ESB). So a micro frontend using REST and JSON can invoke a request that goes all the way down to old\nlegacy "stuff" eg a Cobol mainframe / AS400 / C++, then it comes all the way back up the layers.'}),"\n",(0,r.jsx)(t.h3,{id:"event-driven",children:"Event-Driven"}),"\n",(0,r.jsxs)(t.p,{children:["Is the latest hype, even though it's a fairly old architecture style. It's a ",(0,r.jsx)(t.strong,{children:"reactive"})," architecture, more complex and\nnon-deterministic. Workflows are pushing this trend. Lots of complexity like testing and event timing."]}),"\n",(0,r.jsx)(t.h3,{id:"space-based",children:"Space Based"}),"\n",(0,r.jsxs)(t.p,{children:["Comes from the computer science term ",(0,r.jsx)(t.strong,{children:"tuple space"}),". Multiple parallel processors with shared memory. Therefore all\ntransactional data is cached in memory and DB is not used in the interactions of transactional processing. Provides\nhighest volumes of elasticity, scalability and performance out of any of the architectural styles, because it removes\nthe DB limiting constraint (bottleneck)."]}),"\n",(0,r.jsx)(t.h3,{id:"microservices-challenge",children:"Microservices Challenge"}),"\n",(0,r.jsx)(t.p,{children:"How to manage the transactionality when data is split between different bounded contexts?"}),"\n",(0,r.jsx)(t.p,{children:"Encapsulate business behaviour behind a platform, e.g. a group of microservices behind an API layer. The API layer can\nhave a slow rate of change, therefore introducing stability and reuse."}),"\n",(0,r.jsx)(t.h3,{id:"hybrid-architecture",children:"Hybrid Architecture"}),"\n",(0,r.jsx)(t.p,{children:"Service based, microservices architecture. Where not all of a system have to be microservices. Do all the area's meet the\ncharacteristics of microservices?"}),"\n",(0,r.jsx)(t.p,{children:"Microservices-event driven (or event driven microservices)"}),"\n",(0,r.jsx)(t.h2,{id:"distributed-architecture-consdierations",children:"Distributed Architecture Consdierations"}),"\n",(0,r.jsx)(t.h2,{id:"the-fallacies-of-distributed-computing",children:"The Fallacies of Distributed Computing"}),"\n",(0,r.jsxs)(t.p,{children:["Suggested by L. Peter Deutsch and colleagues from Sun Microsystems in 1994, these fallacies still hold worthy consideration\ntoday. ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing",children:"https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing"})]}),"\n",(0,r.jsx)(t.h3,{id:"the-network-is-reliable",children:"The Network is Reliable"}),"\n",(0,r.jsx)(t.p,{children:"Do not assume that the network is reliable, even though they have become more reliable over time, they remain generally\nunreliable. Distributed architectures rely on the network for communication between services. Even though all the services\nmay be up and healthy, if they cannot communicate with each other the system as a whole may not be healthy. Make sure\nto consider things like timeouts and circuit breakers to prevent phenomena like cascade failures."}),"\n",(0,r.jsx)(t.h3,{id:"latency-is-zero",children:"Latency is Zero"}),"\n",(0,r.jsx)(t.p,{children:"When you call some method in another service using something like REST or RPC, the measurment of time is usually in milliseconds.\nCompare that to internal method calls where we're measuring in nano or microseconds."}),"\n",(0,r.jsx)(t.h2,{id:"service-granularity",children:"Service Granularity"}),"\n",(0,r.jsx)(t.h3,{id:"granularity-disintegrators",children:"Granularity Disintegrators"}),"\n",(0,r.jsx)(t.p,{children:"Reasons to separate services"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Service functionality"})," (cohesion)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Code volatility"})," - do some parts not change much (examination of git hostory could inform?). Would a single service mean some aspect is down for\nan unrelated change (e.g. deploy of something else)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Scalability and Throughput"})," - mean time to start (MTTS). Does one thing take a long time to start but others are\nreally quick?"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Fault Tolerance"})," - If one aspect goes down a lot, it would take other aspects down that are grouped into the single\nservice - mean time to recovery (MTTR)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Data Security"})," - would one aspect benefit from more or greater security"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"granularity-integrators",children:"Granularity Integrators"}),"\n",(0,r.jsx)(t.p,{children:"Favours monoliths. Converse of above granularity disintegrators, i.e. here are reasons to combine services"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"DB transactions - Do you need ACID more than something else?"}),"\n",(0,r.jsx)(t.li,{children:'Workflow choreography - network, security and data latency. Big ball of "distributed" mud. E.g. few ms for security\nprocessing, few more for network, more still for data, multiplied by "n" calls per second means a potential large\ncumulative latency. This can become worse still if you need timeout-retries, data consistency considerations etc'}),"\n",(0,r.jsx)(t.li,{children:"Data dependencies - If two services need the same data, might they be better as a single service to avoid calling each\nother and the data consistency problem therin"}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,n.RP)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,t,i)=>{i.d(t,{RP:()=>s});var r=i(6540);const n=r.createContext({});function s(e){const t=r.useContext(n);return r.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}}}]);