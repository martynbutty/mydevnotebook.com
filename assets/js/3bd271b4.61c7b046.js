"use strict";(self.webpackChunkmydevnotebook_com=self.webpackChunkmydevnotebook_com||[]).push([[1028],{9511:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var t=s(4848),i=s(8453);const r={layout:"post",title:"The Fragile Base Class Problem",permalink:"/fragile/",categories:["OOP"],order:100},l=void 0,a={id:"Design Patterns and Principles/fragile",title:"The Fragile Base Class Problem",description:"The fragile base class problem is caused by the use of implementation inheritance. It occurs when a derived class extends a base class, using some of the methods or attributes in the base class.",source:"@site/docs/Design Patterns and Principles/fragile.md",sourceDirName:"Design Patterns and Principles",slug:"/Design Patterns and Principles/fragile",permalink:"/Design Patterns and Principles/fragile",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{layout:"post",title:"The Fragile Base Class Problem",permalink:"/fragile/",categories:["OOP"],order:100},sidebar:"tutorialSidebar",previous:{title:"The Factory Method Pattern",permalink:"/Design Patterns and Principles/factory"},next:{title:"The Strategy Pattern",permalink:"/Design Patterns and Principles/strategy"}},o={},c=[{value:"Code Reuse via Composition",id:"code-reuse-via-composition",level:2},{value:"Obtaining Polymorphism Using Composition",id:"obtaining-polymorphism-using-composition",level:2}];function d(e){const n={code:"code",em:"em",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,i.RP)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The fragile base class"})," problem is caused by the use of ",(0,t.jsx)(n.em,{children:"implementation inheritance"}),". It occurs when a derived class extends a base class, using some of the methods or attributes in the base class."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Fragile Base Class UML",src:s(338).A+"",width:"1024",height:"401"})}),"\n",(0,t.jsx)(n.p,{children:"The derived class is tightly coupled to the base class. This is because the derived class expects the methods or attributes of the base class that it uses, to be of a certain type, or do things in a certain way. This means you cannot modify the base class without having to examine every derived class that inherits from the base class, and the client code that uses either the base or derived class objects."}),"\n",(0,t.jsx)(n.p,{children:"Let's look at an example to illustrate the problem."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"class Fruit {  \n  // Return int number of pieces of peel that resulted from the peeling activity  \n  public int peel() {  \n    return 1;  \n  }  \n}  \n  \nclass Apple extends Fruit { }  \n  \nclass Example1 {  \n  public static void main(String[] args) {  \n    Apple apple = new Apple();  \n    int pieces = apple.peel();  \n  }  \n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["What would happen if you changed the return type of ",(0,t.jsx)(n.code,{children:"peel"})," from ",(0,t.jsx)(n.code,{children:"int"})," to the type ",(0,t.jsx)(n.code,{children:"Peel"}),"?"]}),"\n",(0,t.jsxs)(n.p,{children:["The client code now no longer works as it is expecting an ",(0,t.jsx)(n.code,{children:"int"})," to be returned, even though the class ",(0,t.jsx)(n.code,{children:"Example1"})," never explicitly mentions the ",(0,t.jsx)(n.code,{children:"Fruit"})," class"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"coupling"})," The undesirable reliance of one part of a program on another part"]}),"\n",(0,t.jsx)(n.h2,{id:"code-reuse-via-composition",children:"Code Reuse via Composition"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Composition"})," provides an alternative way for ",(0,t.jsx)(n.code,{children:"Apple"})," to reuse ",(0,t.jsx)(n.code,{children:"Fruit's"})," implementation of ",(0,t.jsx)(n.code,{children:"peel()"}),". Instead of extending ",(0,t.jsx)(n.code,{children:"Fruit"}),", ",(0,t.jsx)(n.code,{children:"Apple"})," can hold a reference to a ",(0,t.jsx)(n.code,{children:"Fruit"})," instance and define its own ",(0,t.jsx)(n.code,{children:"peel()"})," method that simply invokes ",(0,t.jsx)(n.code,{children:"peel()"})," on the ",(0,t.jsx)(n.code,{children:"Fruit"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"class Fruit {  \n  // Return int number of pieces of peel that resulted from the peeling activity  \n  public int peel() {  \n    return 1;  \n  }  \n}  \n  \nclass Apple extends Fruit {  \n  private Fruit fruit = new Fruit();  \n  public int peel() {  \n    return fruit.peel();  \n  }  \n}  \n  \nclass Example2 {  \n  public static void main(String[] args) {  \n    Apple apple = new Apple();  \n    int pieces = apple.peel();  \n  }  \n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"composition"})," approach to code reuse provides ",(0,t.jsx)(n.strong,{children:"stronger encapsulation"})," than ",(0,t.jsx)(n.strong,{children:"inheritance"}),", because a change to a back-end class (",(0,t.jsx)(n.code,{children:"Fruit"}),") needn't break any code that relies only on the front-end class. For example, changing the return type of Fruit's ",(0,t.jsx)(n.code,{children:"peel()"})," method from an ",(0,t.jsx)(n.code,{children:"int"})," to a ",(0,t.jsx)(n.code,{children:"Peel"})," doesn't force a change in ",(0,t.jsx)(n.code,{children:"Apple"}),"'s interface and therefore needn't break class ",(0,t.jsx)(n.code,{children:"Example2"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"class Fruit {  \n  // Return Peel number of pieces of peel that resulted from the peeling activity  \n  public Peel peel() {  \n    return Peel(1);  \n  }  \n}  \n  \nclass Apple extends Fruit {  \n  // Apple must be changed to accommodate the change to Fruit  \n  private Fruit fruit = new Fruit();  \n  public int peel() {  \n    Peel peel = fruit.peel();  \n    return peel.getPeelCount();  \n  }  \n}  \n  \nclass Example2 {  \n  public static void main(String[] args) {  \n    Apple apple = new Apple();  \n    int pieces = apple.peel();  \n  }  \n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"obtaining-polymorphism-using-composition",children:"Obtaining Polymorphism Using Composition"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Polymorphism"})," is still possible when using composition, but we need to use ",(0,t.jsx)(n.strong,{children:"type inheritance"})," to gain a common parent type."]}),"\n",(0,t.jsxs)(n.p,{children:["In the diagram, the ",(0,t.jsx)(n.code,{children:"FoodProcessor"})," can peel anything that implements ",(0,t.jsx)(n.code,{children:"Peelable"})," since these objects all inherit the ",(0,t.jsx)(n.code,{children:"Peelable"})," type."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Note"})," that there is ",(0,t.jsx)(n.strong,{children:"polymorphism"})," with the subtypes of ",(0,t.jsx)(n.code,{children:"Peelable"})," using ",(0,t.jsx)(n.code,{children:"peel()"}),", but the ",(0,t.jsx)(n.code,{children:"peel"})," implementation is always delegated to ",(0,t.jsx)(n.code,{children:"Fruit"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,i.RP)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},338:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/fragile_base_class_uml-1ac4e75d3b46dc5dba9c810720094bbc.png"},8453:(e,n,s)=>{s.d(n,{RP:()=>r});var t=s(6540);const i=t.createContext({});function r(e){const n=t.useContext(i);return t.useMemo((()=>"function"==typeof e?e(n):{...n,...e}),[n,e])}}}]);